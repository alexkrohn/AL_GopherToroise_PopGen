Finding the “Best” K from conStruct Runs
================

## Introduction

This doc will lead you through the steps to compare spatial and
non-spatial conStruct models, then use predictive accuracy and layer
contributions to see if there is a “best” K in the conStruct analyses.

Many of these functions are taken directly from the `conStruct` package.
See the vignettes below for references.

``` r
library(conStruct)
library(tidyverse)

vignette(topic = "visualize-results", package = "conStruct")
vignette(topic = "model-comparison", package = "conStruct")
vignette(topic = "run-conStruct", package = "conStruct")
```

# Analyzing All Sites Gopher Tortoise Subset

This dataset uses 57 individuals and 8422 SNPs and evaluated K 1-7.
These functions can be applied to any of the subsets.

# Predictive Accuracy

The functions below help determine whether a spatial or non-spatial
model most increase the accuracy of the model.

``` r
setwd("allinds")

# Import the results
sp.results <- as.matrix(read.table("k1-7_sp_xval_results.txt", header = TRUE, stringsAsFactors = FALSE))

nsp.results <- as.matrix(read.table("k1-7_nsp_xval_results.txt", header = TRUE, stringsAsFactors = FALSE))

# first, get the 95% confidence intervals for the spatial and nonspatial models
# over values of K (mean +/- 1.96 the standard error)
sp.CIs <- apply(sp.results, 1, function(x) {
    mean(x) + c(-1.96, 1.96) * sd(x)/length(x)
})
nsp.CIs <- apply(nsp.results, 1, function(x) {
    mean(x) + c(-1.96, 1.96) * sd(x)/length(x)
})

# Plot cross-validation results, spatial in blue, non-spatial in green
par(mfrow = c(1, 2))
plot(rowMeans(sp.results), pch = 19, col = "blue", ylab = "predictive accuracy",
    xlab = "values of K", ylim = range(sp.results, nsp.results), main = "cross-validation results")
points(rowMeans(nsp.results), col = "green", pch = 19)


# finally, visualize results for the spatial model separately with its
# confidence interval bars

plot(rowMeans(sp.results), pch = 19, col = "blue", ylab = "predictive accuracy",
    xlab = "values of K", ylim = range(sp.CIs), main = "spatial cross-validation results")
segments(x0 = 1:nrow(sp.results), y0 = sp.CIs[1, ], x1 = 1:nrow(sp.results), y1 = sp.CIs[2,
    ], col = "blue", lwd = 2)
```

# Layer Contributions

These functions help determine if increasing K (i.e. adding more layers)
contributes more to the understanding of the data. The “best” K would be
one where adding additional K’s stops contributing to the understanding
of the data. In reality, generally the contributions tend to increase
with the number of Ks.

Because the spatial model was more predictive than the non-spatial,
we’ll use those data for layer contributions.

``` r
# Loop through output files generated by conStruct runs with K=1 through 5 and
# calculate the layer contributions for each layer in each run
total.ks <- 7

layer.contributions <- matrix(NA, nrow = total.ks, ncol = total.ks)

# load the conStruct.results.Robj and data.block.Robj files saved at the end of
# a conStruct run. Choose a random rep for each K
load("k1-7_sp_rep9K1_conStruct.results.Robj")
load("k1-7_sp_rep9K1_data.block.Robj")

# calculate layer contributions
layer.contributions[, 1] <- c(calculate.layer.contribution(conStruct.results[[1]],
    data.block), rep(0, total.ks - 1))
tmp <- conStruct.results[[1]]$MAP$admix.proportions


for (i in 2:total.ks) {
    # load the conStruct.results.Robj and data.block.Robj files saved at the
    # end of a conStruct run
    load(sprintf("k1-4_sp_rep9K%s_conStruct.results.Robj", i))
    load(sprintf("k1-4_sp_rep9K%s_data.block.Robj", i))

    # match layers up across runs to keep plotting colors consistent for the
    # same layers in different runs
    tmp.order <- match.layers.x.runs(tmp, conStruct.results[[1]]$MAP$admix.proportions)

    # calculate layer contributions
    layer.contributions[, i] <- c(calculate.layer.contribution(conStruct.results = conStruct.results[[1]],
        data.block = data.block, layer.order = tmp.order), rep(0, total.ks - i))
    tmp <- conStruct.results[[1]]$MAP$admix.proportions[, tmp.order]
}

# Plot the contributions
dev.off()
barplot(layer.contributions, col = c("blue", "red", "goldenrod1", "forestgreen"),
    xlab = "", ylab = "layer contributions", names.arg = paste0("K=", 1:total.ks))
```
